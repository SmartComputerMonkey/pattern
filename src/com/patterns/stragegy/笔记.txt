
注意点：
	1、分析项目中变化部分与不变化部分 如：鸭子项目中，飞行行为和叫声行为是变化的，将变化部分做成行为族；
	      分析成不变化部分和变化部分，其中变化部分做成行为族之后，这些行为之间是不是可以替换的，变化部分相互之间行为是可以替换的；
	      而且不同的变化部分，比如叫声行为和飞行行为是相互独立，所以用策略模式抽象出接口和行为族，然后相同的行为之间是可以相互替换；
	      不同的行为之间是相互独立没有影响的
	2、多用组合少用继承；用行为类组合，而不是行为的继承。更有弹性
	   通过继承的方式来做，虽然达到代码的复用；但是通过继承实现代码复用的情况下，同时也把这个影响增加到其他的子类，有些子类不需要这个功能，
	  也复用过去了，没有办法控制区域性，同时不把实现代码放到超类里边， 放到子类里边实现，子类中有相同行为的子类，每个子类都要实现相同的代码，代码复用性又不好了；
	 用策略模式的话，将行为进行抽象为接口和实现，变成行为之间使用的话是组合的，就是在一个超类里边或在一个子类里边就把具体的行为做行为对象来作为调用。
	3、设计模式有没有相应的库直接使用？有些库或框架本省就用某种设计模式设计的
	4、如果找不到适用的模式怎么办？分析不够
策略模式的定义：
	分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。
	原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者。
优缺点：
	优点：
		新增行为简单，行为类更好的复用，组合更方便。既有继承带来的复用好处，没有挖坑
类结构：
	将行为定义为接口  拥有不同的行为  可以定义不同的行为类族，并在类里边实现不同的行为算法
	将共同的特性抽象为超类，并在超类中定义接口对象，超类中定义行为方法，但是没有具体实现，而是通过接口对象，调用对应的实现算法
	超类中提供set方法，可以灵活修改行为，将行为接口对象定义为set方法的接收参数，这里利用多态的思想，将行为接口对象的实现类映射过来
	所以在改变不同行为时，只需将要修改的行为类对象传入即可
	继承超类的子类中，构造方法中定义要实现的行为对象，子类中也可以实现超类中的抽象方法
	
继承的问题：对类的局部改动，尤其超类的局部改动，会影响其他部分。影响会有溢出效应
超类挖的一个坑，每个自雷都要来填，增加工作量，复杂度0（N^2）。不是好的设计方式
